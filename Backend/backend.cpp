#include <stdio.h>
#include <sys/stat.h>
// include the enscripten library in order to use Embind. emcc will be able to
// find it, even though vscode can not, so don't mind the squiggles.
// #include <emscripten/bind.h>
#include <array>
#include <complex>
#include <filesystem>
#include <iostream>
#include <limits>
#include <string>

// Functions must be "prototyped" in C++ before main, or main will not recognize
// them.
int testJSFunctionality();
int normalizeState(std::complex<double> alpha, std::complex<double> beta);
int main() {
  normalizeState(std::complex<double>(1, 2), std::complex<double>(2, 3));

  return 0;
}

// Register Embind bindings for this translation unit.
// EMSCRIPTEN_BINDINGS(...) is a macro (not a namespace member), so it is not
// written as emscripten::EMSCRIPTEN_BINDINGS.
//
// The name `my_module` is just an arbitrary identifier used to make the
// generated registration code unique; you don't define a variable or object
// called `my_module`. Inside this block you list what C++ functions/classes you
// want exposed to the JS-facing module API (via wrappers generated by
// Emscripten/Embind).
//
// Design note (for this project): keep the JS-facing surface small and expose
// "essential" operations/data, while leaving the heavy QM math in C++.
/*EMSCRIPTEN_BINDINGS(my_module) {
  // Embind the function. First comes the name of the function as js will see
  // it, and second comes the reference to the actual function in your c++ code.
  emscripten::function("testJS", &testJSFunctionality);
}*/

// The full function that exists for testing js integration
int testJSFunctionality() { return 2 + 3; }

// Normalize the state using the values of probZero, probOne, and
// sqrNormalization (the squared normalization factor). The normalized
// amplitudes (i.e alpha/N) and the normalized probabilities (|alpha|^2/N^2) are
// NOT the same! TODO check for unnecessary calculations and fix
// sqrNormalization is zero error
int normalizeState(std::complex<double> alpha, std::complex<double> beta) {
  // First, check if sqrNormalization is zero. If it is, figure out a way to
  // deal with this later TODO
  if (sqrNormalization == 0) {
    return -1;
  }
  // Next, divide each unnormalized probability to get their true probability
  probOne = probOne / sqrNormalization;
  probZero = probZero / sqrNormalization;
  // Next, calculate the sqrt of the squared normalization factor to get the
  // normalize amplitude factor.
  double normAmpFactor = std::sqrt(sqrNormalization);
  // Normalize alpha and beta
  alpha = alpha / normAmpFactor;
  beta = beta / normAmpFactor;
  std::cout << alpha << " normalized and normalized " << beta << std::endl;
  // Return zero to end the function
  return 0;
}