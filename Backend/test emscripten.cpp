#include <stdio.h>
#include <sys/stat.h>
// include the enscripten library in order to use Embind. emcc will be able to
// find it, even though vscode can not, so don't mind the squiggles.
#include <emscripten/bind.h>

#include <array>
#include <filesystem>
#include <iostream>
#include <limits>
#include <string>

// Functions must be "prototyped" in C++ before main, or main will not recognize
// them.
int testJSFunctionality();

// Function to check that a file exists in the path. Used because I dont know
// how else to navigate the virtual file system.
static void check_file(const char* path) {
  struct stat st;
  int rc = stat(path, &st);
  if (rc == 0) {
    printf("FOUND %s (size=%lld)\n", path, (long long)st.st_size);
  } else {
    printf("MISSING %s (errno=%d)\n", path, errno);
  }
}

int main() {
  int num = testJSFunctionality();
  /* How to use virtual files provided by emscripten below
  std::cout << "cwd = " << std::filesystem::current_path() << std::endl;
  std::cout.flush();
  FILE* file = fopen("/test.txt", "rb");
  if (!file) {
    printf("cannot open file\n");
    return 1;
  }
  while (!feof(file)) {
    int c = fgetc(file);
    if (c != EOF) {
      std::cout.put(static_cast<char>(c));
    }
  }
  fclose(file);
  // So emscription doesnt have a fit from repeated cout. Needs to be endl or
  // '\n' for transcompilation to js to work with the couts.
  std::cout << std::endl;
  */
  return 0;
}

// Register Embind bindings for this translation unit.
// EMSCRIPTEN_BINDINGS(...) is a macro (not a namespace member), so it is not
// written as emscripten::EMSCRIPTEN_BINDINGS.
//
// The name `my_module` is just an arbitrary identifier used to make the
// generated registration code unique; you don't define a variable or object
// called `my_module`. Inside this block you list what C++ functions/classes you
// want exposed to the JS-facing module API (via wrappers generated by
// Emscripten/Embind).
//
// Design note (for this project): keep the JS-facing surface small and expose
// "essential" operations/data, while leaving the heavy QM math in C++.
EMSCRIPTEN_BINDINGS(my_module) {
  // Embind the function. First comes the name of the function as js will see
  // it, and second comes the reference to the actual function in your c++ code.
  emscripten::function("testJS", &testJSFunctionality);
}

// The full function that exists for testing js integration
int testJSFunctionality() { return 2 + 3; }