Text validation using math.parse: Math.parse takes any expression and makes it into a detailed tree, where each node represents a node type and the value. For example, it breaks up the expression (3 * 4) into a tree that looks something like: 3 (constant), * (expression), 4 (constant). Using math.parse allows me to include certain values while excluding others, all without having to write my own parsing logic.


Challenges faced: It was hard to figure out the node structure of the tree and how to deal with functions (i.e. cos) being symbols and functions when I wanted to remove all "symbols" (i.e. x, y). Resolved by using a list of acceptable values and carefully checking if a symbol was a function symbol by checking that the parent was a function node and that the path was a function (fn).

I originally had the validate input function return the exact error type and the text that was a problem as one full string to the app. So I could give feedback to the user on why their input wasn't accepted. However, both pieces of information being one string meant I couldn't do any styling on only or the other. To fix this, I started to return an object containing an error number and the name of the error. This let me make a new function that returned jsx of the error description + the specific bolded error if needed.
This didn't affect performance because the new function did not add much time to run, and returning an object with two values takes about the same amount of time as returning a concatenated string. It even forced me to look more carefully at my validation function and add improvements (now it correctly stops checking for more errors as soon as one is found).

Had trouble figuring out how to resize visual elements like the selector to be a good size. 
Fixed it by using bootstraps 12 column system and giving smaller elements less columns and bigger elements more columns.

When implementing the button 'normalize for me' I ran into a strange issue where highlighting and replacing the values in the text boxes would not cause the relevant components to rerender. This means that even though the user changed their expression, the ui would still give them the feedback that their state was normalized, which leads to bad UX at the least (after all, they cant click normalize for me again if the state seems normalized) and crashes at the worse (if they tried to use operation that requires normalized values that don't exist). On further inspection, I realized that it was only when the user replaced the text with what they had before clicking on normalize for me. This made the issue clear to me: react was recognizing the change, but my code, which relies on the text being different, was not. This was because even though I updated the value the user saw in the text box, on the frontend code, since the values I was doing math with and the values the users saw had to be different, that internal 'math only' value was not being updated. Once I made it so updating what the user saw updated this 'math value', the bug went away, as all the components were properly rerendered. What I learned was not just that you need to make sure to update all relevant values, but that having two values that represent the same thing sometimes but different things other times can get very confusing. I learned to avoid this as much as possible in the future, and vowed to try and find a way to combine the two values in the code as soon as I got the chance. Later, I was able to find a clear way to change these two sources of truth into one, keeping the functionality of the code while making it clearer the purpose of each value.