Text validation using math.parse: Math.parse takes any expression and makes it into a detailed tree, where each node represents a node type and the value. For example, it breaks up the expression (3 * 4) into a tree that looks something like: 3 (constant), * (expression), 4 (constant). Using math.parse allows me to include certain values while excluding others, all without having to write my own parsing logic.


Challenges faced: It was hard to figure out the node structure of the tree and how to deal with functions (i.e. cos) being symbols and functions when I wanted to remove all "symbols" (i.e. x, y). Resolved by using a list of acceptable values and carefully checking if a symbol was a function symbol by checking that the parent was a function node and that the path was a function (fn).

I originally had the validate input function return the exact error type and the text that was a problem as one full string to the app. So I could give feedback to the user on why their input wasn't accepted. However, both pieces of information being one string meant I couldn't do any styling on only or the other. To fix this, I started to return an object containing an error number and the name of the error. This let me make a new function that returned jsx of the error description + the specific bolded error if needed.
This didn't affect performance because the new function did not add much time to run, and returning an object with two values takes about the same amount of time as returning a concatenated string. It even forced me to look more carefully at my validation function and add improvements (now it correctly stops checking for more errors as soon as one is found).

Had trouble figuring out how to resize visual elements like the selector to be a good size. 
Fixed it by using bootstraps 12 column system and giving smaller elements less columns and bigger elements more columns.